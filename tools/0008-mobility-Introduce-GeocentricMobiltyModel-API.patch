From 058ce16fb3803ceff2caea48e53bb7272af13509 Mon Sep 17 00:00:00 2001
From: Giovanni Grieco <giovanni.grieco@poliba.it>
Date: Sun, 25 Jun 2023 10:56:31 +0000
Subject: [PATCH] mobility: Introduce GeocentricMobiltyModel API

---
 src/mobility/CMakeLists.txt                   |   4 +-
 ...entric-constant-position-mobility-model.cc | 224 +++----------
 ...centric-constant-position-mobility-model.h | 144 +--------
 .../model/geocentric-mobility-model.cc        | 168 ++++++++++
 .../model/geocentric-mobility-model.h         | 145 +++++++++
 .../model/channel-condition-model.cc          | 102 +++---
 .../model/three-gpp-propagation-loss-model.cc | 294 +++++++-----------
 .../examples/three-gpp-ntn-channel-example.cc |   6 +-
 src/spectrum/model/three-gpp-channel-model.cc |  33 +-
 9 files changed, 539 insertions(+), 581 deletions(-)
 create mode 100644 src/mobility/model/geocentric-mobility-model.cc
 create mode 100644 src/mobility/model/geocentric-mobility-model.h

diff --git a/src/mobility/CMakeLists.txt b/src/mobility/CMakeLists.txt
index 3675c9273..42b15331b 100644
--- a/src/mobility/CMakeLists.txt
+++ b/src/mobility/CMakeLists.txt
@@ -11,6 +11,7 @@ build_lib(
     model/constant-velocity-mobility-model.cc
     model/gauss-markov-mobility-model.cc
     model/geocentric-constant-position-mobility-model.cc
+    model/geocentric-mobility-model.cc
     model/geographic-positions.cc
     model/hierarchical-mobility-model.cc
     model/mobility-model.cc
@@ -33,6 +34,7 @@ build_lib(
     model/constant-velocity-mobility-model.h
     model/gauss-markov-mobility-model.h
     model/geocentric-constant-position-mobility-model.h
+    model/geocentric-mobility-model.h
     model/geographic-positions.h
     model/hierarchical-mobility-model.h
     model/mobility-model.h
@@ -54,4 +56,4 @@ build_lib(
     test/rand-cart-around-geo-test.cc
     test/steady-state-random-waypoint-mobility-model-test.cc
     test/waypoint-mobility-model-test.cc
-)
\ No newline at end of file
+)
diff --git a/src/mobility/model/geocentric-constant-position-mobility-model.cc b/src/mobility/model/geocentric-constant-position-mobility-model.cc
index 039cb54b7..677368c4c 100644
--- a/src/mobility/model/geocentric-constant-position-mobility-model.cc
+++ b/src/mobility/model/geocentric-constant-position-mobility-model.cc
@@ -1,5 +1,6 @@
 /*
- * Copyright (c) 2006,2007 INRIA
+ * Copyright (C) 2023 University of Padua.
+ * Copyright (C) 2023 Polytechnic University of Bari.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -14,10 +15,13 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
- * Author: Mattia Sandri
+ * Author: Mattia Sandri,
+ *         Giovanni Grieco <giovanni.grieco@poliba.it>
  */
 #include "geocentric-constant-position-mobility-model.h"
 
+#include "geographic-positions.h"
+
 #include <math.h>
 
 namespace ns3
@@ -26,10 +30,10 @@ namespace ns3
 NS_OBJECT_ENSURE_REGISTERED(GeocentricConstantPositionMobilityModel);
 
 TypeId
-GeocentricConstantPositionMobilityModel::GetTypeId(void)
+GeocentricConstantPositionMobilityModel::GetTypeId()
 {
     static TypeId tid = TypeId("ns3::GeocentricConstantPositionMobilityModel")
-                            .SetParent<MobilityModel>()
+                            .SetParent<GeocentricMobilityModel>()
                             .SetGroupName("Mobility")
                             .AddConstructor<GeocentricConstantPositionMobilityModel>();
     return tid;
@@ -44,198 +48,58 @@ GeocentricConstantPositionMobilityModel::~GeocentricConstantPositionMobilityMode
 }
 
 Vector
-GeocentricConstantPositionMobilityModel::GetGeographicPosition(void) const
-{
-    return DoGetGeographicPosition();
-}
-
-void
-GeocentricConstantPositionMobilityModel::SetGeographicPosition(const Vector& position)
-{
-    DoSetGeographicPosition(position);
-}
-
-Vector
-GeocentricConstantPositionMobilityModel::GetGeocentricPosition(void) const
-{
-    return DoGetGeocentricPosition();
-}
-
-void
-GeocentricConstantPositionMobilityModel::SetGeocentricPosition(const Vector& position)
-{
-    DoSetGeocentricPosition(position);
-}
-
-double
-GeocentricConstantPositionMobilityModel::GetElevationAngle(
-    Ptr<const GeocentricConstantPositionMobilityModel> other)
+GeocentricConstantPositionMobilityModel::DoGetPosition(PositionType type) const
 {
-    return DoGetElevationAngle(other);
-}
-
-void
-GeocentricConstantPositionMobilityModel::SetCoordinateTranslationReferencePoint(
-    const Vector& position)
-{
-    DoSetCoordinateTranslationReferencePoint(position);
-}
-
-Vector
-GeocentricConstantPositionMobilityModel::GetCoordinateTranslationReferencePoint(void) const
-{
-    return DoGetCoordinateTranslationReferencePoint();
-}
-
-Vector
-GeocentricConstantPositionMobilityModel::GetPosition(void) const
-{
-    return DoGetPosition();
-}
-
-void
-GeocentricConstantPositionMobilityModel::SetPosition(const Vector& position)
-{
-    return DoSetPosition(position);
-}
-
-double
-GeocentricConstantPositionMobilityModel::GetDistanceFrom(
-    Ptr<const GeocentricConstantPositionMobilityModel> other) const
-{
-    return DoGetDistanceFrom(other);
-}
-
-Vector
-GeocentricConstantPositionMobilityModel::DoGetPosition(void) const
-{
-    GeographicPositions gp;
-    Vector topographicCoordinates =
-        gp.GeographicToTopocentricCoordinates(m_position,
-                                              m_geographicReferencePoint,
-                                              GeographicPositions::SPHERE);
-    return topographicCoordinates;
+    switch (type)
+    {
+    case PositionType::TOPOCENTRIC:
+        return GeographicPositions::GeographicToTopocentricCoordinates(
+            m_position,
+            GetCoordinateTranslationReferencePoint(),
+            GetEarthSpheroidType());
+    case PositionType::GEOCENTRIC:
+        return GeographicPositions::GeographicToCartesianCoordinates(m_position.x,
+                                                                     m_position.y,
+                                                                     m_position.z,
+                                                                     GetEarthSpheroidType());
+    case PositionType::GEOGRAPHIC:
+    default:
+        return m_position;
+    }
 }
 
 void
-GeocentricConstantPositionMobilityModel::DoSetPosition(const Vector& position)
+GeocentricConstantPositionMobilityModel::DoSetPosition(Vector position, PositionType type)
 {
-    GeographicPositions gp;
-    Vector geographicCoordinates =
-        gp.TopocentricToGeographicCoordinates(position,
-                                              m_geographicReferencePoint,
-                                              GeographicPositions::SPHERE);
-    m_position = geographicCoordinates;
-    NotifyCourseChange();
-}
-
-double
-GeocentricConstantPositionMobilityModel::DoGetDistanceFrom(
-    Ptr<const GeocentricConstantPositionMobilityModel> other) const
-{
-    GeographicPositions gp;
-
-    Vector cartesian_coord1 = gp.GeographicToCartesianCoordinates(m_position.x,
-                                                                  m_position.y,
-                                                                  m_position.z,
-                                                                  gp.EarthSpheroidType::SPHERE);
-    Vector cartesian_coord2 = other->DoGetGeocentricPosition();
-
-    double distance = sqrt(pow(cartesian_coord1.x - cartesian_coord2.x, 2) +
-                           pow(cartesian_coord1.y - cartesian_coord2.y, 2) +
-                           pow(cartesian_coord1.z - cartesian_coord2.z, 2));
-
-    return distance;
-}
-
-Vector
-GeocentricConstantPositionMobilityModel::DoGetGeographicPosition(void) const
-{
-    return m_position;
-}
+    switch (type)
+    {
+    case PositionType::TOPOCENTRIC:
+        m_position = GeographicPositions::TopocentricToGeographicCoordinates(
+            position,
+            GetCoordinateTranslationReferencePoint(),
+            GetEarthSpheroidType());
+        break;
+    case PositionType::GEOCENTRIC:
+        m_position =
+            GeographicPositions::CartesianToGeographicCoordinates(position, GetEarthSpheroidType());
+        break;
+    case PositionType::GEOGRAPHIC:
+    default:
+        m_position = position;
+        break;
+    }
 
-void
-GeocentricConstantPositionMobilityModel::DoSetGeographicPosition(const Vector& position)
-{
     NS_ASSERT_MSG((m_position.x >= -90) && (m_position.x <= 90),
                   "Latitude must be between -90 deg and +90 deg");
     NS_ASSERT_MSG((m_position.y >= -180) && (m_position.y <= 180),
                   "Longitude must be between -180 deg and +180 deg");
     NS_ASSERT_MSG(m_position.z >= 0, "Altitude must be higher or equal 0 meters");
-    m_position = position;
-    NotifyCourseChange();
-}
 
-Vector
-GeocentricConstantPositionMobilityModel::DoGetGeocentricPosition(void) const
-{
-    GeographicPositions gp;
-    Vector geocentric_coord = gp.GeographicToCartesianCoordinates(m_position.x,
-                                                                  m_position.y,
-                                                                  m_position.z,
-                                                                  gp.EarthSpheroidType::SPHERE);
-    return geocentric_coord;
-}
-
-void
-GeocentricConstantPositionMobilityModel::DoSetGeocentricPosition(const Vector& position)
-{
-    GeographicPositions gp;
-    Vector geographic_coord = gp.CartesianToGeographicCoordinates(position, gp.SPHERE);
-    m_position = geographic_coord;
     NotifyCourseChange();
 }
 
-double
-GeocentricConstantPositionMobilityModel::DoGetElevationAngle(
-    Ptr<const GeocentricConstantPositionMobilityModel> other)
-{
-    NS_ASSERT_MSG(m_position.z < 8000,
-                  "Altitude of the ground terminal needs to be lower than 8km");
-    NS_ASSERT_MSG(other->GetGeographicPosition().z >= 8000,
-                  "Altitude of the HAPS/Satellite needs to be higher than 8km");
-    NS_ASSERT_MSG(m_position.z < other->DoGetGeographicPosition().z,
-                  "Altitude of the argoument node needs to be higher than object node");
-
-    double elev_angle = 0;
-    Vector a = this->DoGetGeocentricPosition();
-    Vector b = other->DoGetGeocentricPosition();
-
-    double numerator = abs(a.x * (b.x - a.x) + a.y * (b.y - a.y) + a.z * (b.z - a.z));
-    double denominator = sqrt(pow(a.x, 2) + pow(a.y, 2) + pow(a.z, 2)) *
-                         sqrt(pow(b.x - a.x, 2) + pow(b.y - a.y, 2) + pow(b.z - a.z, 2));
-
-    double x = numerator / denominator;
-
-    // This is done to avoid the nan returned by the asin function when numbers are "almost" 1,
-    // for example 1.0000000000000002
-    if (x > 1)
-    {
-        x = 1;
-    }
-
-    elev_angle = abs((180.0 * M_1_PI) * asin(x)); // asin returns radiants, we convert to degrees
-
-    NS_ASSERT_MSG(!(isnan(elev_angle)), "asin returned a NaN value");
-
-    return elev_angle;
-}
-
-void
-GeocentricConstantPositionMobilityModel::DoSetCoordinateTranslationReferencePoint(
-    const Vector& refPoint)
-{
-    m_geographicReferencePoint = refPoint;
-}
-
-Vector
-GeocentricConstantPositionMobilityModel::DoGetCoordinateTranslationReferencePoint(void) const
-{
-    return m_geographicReferencePoint;
-}
-
 Vector
-GeocentricConstantPositionMobilityModel::DoGetVelocity(void) const
+GeocentricConstantPositionMobilityModel::DoGetVelocity() const
 {
     return Vector(0.0, 0.0, 0.0);
 }
diff --git a/src/mobility/model/geocentric-constant-position-mobility-model.h b/src/mobility/model/geocentric-constant-position-mobility-model.h
index 50ee4341e..21f22efa6 100644
--- a/src/mobility/model/geocentric-constant-position-mobility-model.h
+++ b/src/mobility/model/geocentric-constant-position-mobility-model.h
@@ -1,5 +1,6 @@
 /*
- * Copyright (c) 2006,2007 INRIA
+ * Copyright (C) 2023 University of Padua.
+ * Copyright (C) 2023 Polytechnic University of Bari.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -14,13 +15,13 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
- * Author: Mattia Sandri
+ * Author: Mattia Sandri,
+ *         Giovanni Grieco <giovanni.grieco@poliba.it>
  */
 #ifndef GEOCENTRIC_CONSTANT_POSITION_MOBILITY_MODEL_H
 #define GEOCENTRIC_CONSTANT_POSITION_MOBILITY_MODEL_H
 
-#include "geographic-positions.h"
-#include "mobility-model.h"
+#include "geocentric-mobility-model.h"
 
 namespace ns3
 {
@@ -30,144 +31,31 @@ namespace ns3
  *
  * \brief Mobility model using geocentric euclidean coordinates, as defined in 38.811 chapter 6.3
  */
-class GeocentricConstantPositionMobilityModel : public MobilityModel
+class GeocentricConstantPositionMobilityModel : public GeocentricMobilityModel
 {
   public:
     /**
      * Register this type with the TypeId system.
      * \return the object TypeId
      */
-    static TypeId GetTypeId(void);
+    static TypeId GetTypeId();
     /**
      * Create a position located at coordinates (0,0,0)
      */
     GeocentricConstantPositionMobilityModel();
-    virtual ~GeocentricConstantPositionMobilityModel();
-
-    /**
-     * \brief Computes elevation angle between a ground terminal and a HAPS/Satellite.
-     * After calculating the plane perpendicular to one cartesian position vector,
-     * the elevation angle is calculated using
-     * https://www.w3schools.blog/angle-between-a-line-and-a-plane. The altitude of the node passed
-     * as parameter needs to be higher.
-     * \param other pointer to the HAPS/Satellite mobility model
-     * \return the elevation angle in degrees
-     */
-    virtual double GetElevationAngle(Ptr<const GeocentricConstantPositionMobilityModel> other);
-
-    /**
-     * \brief Get the position using geographic (geodetic) coordinates
-     * \return Vector containing (latitude, longitude, altitude)
-     */
-    virtual Vector GetGeographicPosition(void) const;
-
-    /**
-     * \brief Set the position using geographic coordinates
-     * \param position pointer to a Vector containing (latitude, longitude, altitude)
-     */
-    virtual void SetGeographicPosition(const Vector& position);
-
-    /**
-     * \brief Get the position using Geocentric Cartesian coordinates
-     * \return Vector containing (X, Y, Z)
-     */
-    virtual Vector GetGeocentricPosition(void) const;
-
-    /**
-     * \brief Set the position using geographic coordinates
-     * \param position pointer to a Vector containing (latitude, longitude, altitude)
-     */
-    virtual void SetGeocentricPosition(const Vector& position);
-
-    /**
-     * \brief Set the reference point for coordinate translation
-     * \param refPoint vector containing the geographic reference point
-     */
-    virtual void SetCoordinateTranslationReferencePoint(const Vector& refPoint);
-
-    /**
-     * \brief Get the reference point for coordinate translation
-     * \return Vector containing geographic reference point
-     */
-    virtual Vector GetCoordinateTranslationReferencePoint(void) const;
-
-    /**
-     * \brief Get the position in planar Cartesian coordinates, using m_geographicReferencePoint as
-     * reference. \return Vector containing the planar Cartesian coordinates (X, Y, Z)
-     */
-    virtual Vector GetPosition(void) const;
-
-    /**
-     * \brief Set the position in planar Cartesian coordinates, using m_geographicReferencePoint as
-     * reference. \param position Vector containing the planar Cartesian coordinates (X, Y, Z)
-     */
-    virtual void SetPosition(const Vector& position);
-
-    /**
-     * \brief Get the distance between two nodes.
-     * \param other the mobility model for which the distance from will be calculated
-     * \return the distance in meters
-     */
-    double GetDistanceFrom(Ptr<const GeocentricConstantPositionMobilityModel> other) const;
+    ~GeocentricConstantPositionMobilityModel();
 
   private:
     /**
-     * \brief Get the position in planar Cartesian coordinates, using m_geographicReferencePoint as
-     * reference. \return Vector containing the planar Cartesian coordinates (X, Y, Z)
-     */
-    virtual Vector DoGetPosition(void) const;
-    /**
-     * \brief Set the position in planar Cartesian coordinates, using m_geographicReferencePoint as
-     * reference. \param position Vector containing the planar Cartesian coordinates (X, Y, Z)
-     */
-    virtual void DoSetPosition(const Vector& position);
-    /**
-     * \brief Get the distance between two nodes.
-     * \param other the mobility model for which the distance from will be calculated
-     * \return the distance in meters
-     */
-    double DoGetDistanceFrom(Ptr<const GeocentricConstantPositionMobilityModel> other) const;
-    /**
-     * \brief Get the position using geographic (geodetic) coordinates
-     * \return Vector containing (latitude, longitude, altitude)
-     */
-    virtual Vector DoGetGeographicPosition(void) const;
-    /**
-     * \brief Set the position using geographic coordinates
-     * \param position pointer to a Vector containing (latitude, longitude, altitude)
-     */
-    virtual void DoSetGeographicPosition(const Vector& position);
-    /**
-     * \brief Get the position using Geocentric Cartesian coordinates
-     * \return Vector containing (X, Y, Z)
-     */
-    virtual Vector DoGetGeocentricPosition(void) const;
-    /**
-     * \brief Set the position using Geocentric coordinates
-     * \param position pointer to a Vector containing (X, Y, Z)
-     */
-    virtual void DoSetGeocentricPosition(const Vector& position);
-    /**
-     * \brief Computes elevation angle between a ground terminal and a HAPS/Satellite.
-     * After calculating the plane perpendicular to one cartesian position vector,
-     * the elevation angle is calculated using
-     * https://www.w3schools.blog/angle-between-a-line-and-a-plane. The altitude of the node passed
-     * as parameter needs to be higher. \param other pointer to the HAPS/Satellite mobility model
-     * \return the elevation angle in degrees
-     */
-    virtual double DoGetElevationAngle(Ptr<const GeocentricConstantPositionMobilityModel> other);
-    /**
-     * \brief Set the reference point for coordinate translation
-     * \param refPoint vector containing the geographic reference point
+     * \brief Get the position according to the specified position type.
      */
-    virtual void DoSetCoordinateTranslationReferencePoint(const Vector& refPoint);
+    Vector DoGetPosition(PositionType type) const override;
     /**
-     * \brief Get the reference point for coordinate translation
-     * \return Vector containing geographic reference point
+     * \brief Set the position according to the specified position type.
      */
-    virtual Vector DoGetCoordinateTranslationReferencePoint(void) const;
+    void DoSetPosition(Vector position, PositionType type) override;
 
-    virtual Vector DoGetVelocity(void) const;
+    Vector DoGetVelocity() const override;
 
     /**
      * the constant Geographic position, in degrees, in the order:
@@ -176,12 +64,6 @@ class GeocentricConstantPositionMobilityModel : public MobilityModel
      * altitude
      */
     Vector m_position;
-
-    /**
-     * This is the point taken as reference when converting
-     * from geographic to topographic (aka planar Cartesian)
-     */
-    Vector m_geographicReferencePoint{0, 0, 0};
 };
 
 } // namespace ns3
diff --git a/src/mobility/model/geocentric-mobility-model.cc b/src/mobility/model/geocentric-mobility-model.cc
new file mode 100644
index 000000000..740f60341
--- /dev/null
+++ b/src/mobility/model/geocentric-mobility-model.cc
@@ -0,0 +1,168 @@
+/*
+ * Copyright (C) 2023 University of Padua.
+ * Copyright (C) 2023 Polytechnic University of Bari.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Mattia Sandri,
+ *         Giovanni Grieco <giovanni.grieco@poliba.it>
+ */
+
+#include "geocentric-mobility-model.h"
+
+#include <ns3/enum.h>
+
+namespace ns3
+{
+
+NS_OBJECT_ENSURE_REGISTERED(GeocentricMobilityModel);
+
+TypeId
+GeocentricMobilityModel::GetTypeId()
+{
+    static TypeId tid =
+        TypeId("ns3::GeocentricMobilityModel")
+            .SetParent<MobilityModel>()
+            .SetGroupName("Mobility")
+            .AddAttribute("EarthSpheroidType",
+                          "Spheroid model to use for Earth",
+                          EnumValue(GeographicPositions::SPHERE),
+                          MakeEnumAccessor(&GeocentricMobilityModel::m_earthSpheroidType),
+                          MakeEnumChecker(GeographicPositions::SPHERE,
+                                          "SPHERE",
+                                          GeographicPositions::GRS80,
+                                          "GRS80",
+                                          GeographicPositions::WGS84,
+                                          "WGS84"))
+            .AddAttribute(
+                "CoordinateTranslationReferencePoint",
+                "The reference point used to translate between geographic and geocentric "
+                "coordinates.",
+                VectorValue(Vector(0.0, 0.0, 0.0)),
+                MakeVector3DAccessor(&GeocentricMobilityModel::m_geographicReferencePoint),
+                MakeVector3DChecker());
+    return tid;
+}
+
+GeocentricMobilityModel::GeocentricMobilityModel()
+{
+}
+
+GeocentricMobilityModel::~GeocentricMobilityModel()
+{
+}
+
+Vector
+GeocentricMobilityModel::GetPosition(PositionType type) const
+{
+    return DoGetPosition(type);
+}
+
+void
+GeocentricMobilityModel::SetPosition(Vector position, PositionType type)
+{
+    DoSetPosition(position, type);
+}
+
+double
+GeocentricMobilityModel::GetElevationAngle(Ptr<const GeocentricMobilityModel> other)
+{
+    return DoGetElevationAngle(other);
+}
+
+Vector
+GeocentricMobilityModel::GetCoordinateTranslationReferencePoint() const
+{
+    return DoGetCoordinateTranslationReferencePoint();
+}
+
+void
+GeocentricMobilityModel::SetCoordinateTranslationReferencePoint(const Vector& position)
+{
+    DoSetCoordinateTranslationReferencePoint(position);
+}
+
+GeographicPositions::EarthSpheroidType
+GeocentricMobilityModel::GetEarthSpheroidType() const
+{
+    return m_earthSpheroidType;
+}
+
+Vector
+GeocentricMobilityModel::DoGetPosition() const
+{
+    return DoGetPosition(PositionType::TOPOCENTRIC);
+}
+
+void
+GeocentricMobilityModel::DoSetPosition(const Vector& position)
+{
+    DoSetPosition(position, PositionType::GEOGRAPHIC);
+}
+
+double
+GeocentricMobilityModel::DoGetDistanceFrom(Ptr<const GeocentricMobilityModel> other) const
+{
+    Vector thisPosition = DoGetPosition(PositionType::GEOCENTRIC);
+    Vector otherPosition = other->DoGetPosition(PositionType::GEOCENTRIC);
+    return CalculateDistance(thisPosition, otherPosition);
+}
+
+double
+GeocentricMobilityModel::DoGetElevationAngle(Ptr<const GeocentricMobilityModel> other)
+{
+    const auto& heightA = DoGetPosition(PositionType::GEOGRAPHIC).z;
+    const auto& heightB = other->DoGetPosition(PositionType::GEOGRAPHIC).z;
+    NS_ASSERT_MSG(heightA < 8000, "Altitude of the ground terminal needs to be lower than 8km");
+    NS_ASSERT_MSG(heightB >= 8000, "Altitude of the HAPS/Satellite needs to be higher than 8km");
+    NS_ASSERT_MSG(heightA < heightB,
+                  "Altitude of the argoument node needs to be higher than object node");
+
+    double elev_angle = 0;
+    const auto a = DoGetPosition(PositionType::GEOCENTRIC);
+    const auto b = other->DoGetPosition(PositionType::GEOCENTRIC);
+
+    double numerator = abs(a.x * (b.x - a.x) + a.y * (b.y - a.y) + a.z * (b.z - a.z));
+    double denominator = sqrt(pow(a.x, 2) + pow(a.y, 2) + pow(a.z, 2)) *
+                         sqrt(pow(b.x - a.x, 2) + pow(b.y - a.y, 2) + pow(b.z - a.z, 2));
+
+    double x = numerator / denominator;
+
+    // This is done to avoid the nan returned by the asin function when numbers are "almost" 1,
+    // for example 1.0000000000000002
+    if (x > 1)
+    {
+        x = 1;
+    }
+
+    elev_angle = abs((180.0 * M_1_PI) * asin(x)); // asin returns radiants, we convert to degrees
+
+    NS_ASSERT_MSG(!(isnan(elev_angle)), "asin returned a NaN value");
+
+    return elev_angle;
+}
+
+void
+GeocentricMobilityModel::DoSetCoordinateTranslationReferencePoint(const Vector& refPoint)
+{
+    m_geographicReferencePoint = refPoint;
+}
+
+Vector
+GeocentricMobilityModel::DoGetCoordinateTranslationReferencePoint() const
+{
+    return m_geographicReferencePoint;
+}
+
+} // namespace ns3
diff --git a/src/mobility/model/geocentric-mobility-model.h b/src/mobility/model/geocentric-mobility-model.h
new file mode 100644
index 000000000..8b6a0d8ba
--- /dev/null
+++ b/src/mobility/model/geocentric-mobility-model.h
@@ -0,0 +1,145 @@
+/*
+ * Copyright (C) 2023 University of Padua.
+ * Copyright (C) 2023 Polytechnic University of Bari.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Mattia Sandri,
+ *         Giovanni Grieco <giovanni.grieco@poliba.it>
+ */
+#ifndef GEOCENTRIC_MOBILITY_MODEL_H
+#define GEOCENTRIC_MOBILITY_MODEL_H
+
+#include <ns3/geographic-positions.h>
+#include <ns3/mobility-model.h>
+
+namespace ns3
+{
+
+/**
+ * \ingroup mobility
+ *
+ * \brief Abstract class to mark a mobility model that provides geocentric euclidean coordinates.
+ */
+class GeocentricMobilityModel : public MobilityModel
+{
+  public:
+    /**
+     * \brief The type of coordinates to use for position.
+     * \see ns3::GeographicPositions for more information on these different types of coordinates.
+     */
+    enum class PositionType
+    {
+        TOPOCENTRIC,
+        GEOCENTRIC,
+        GEOGRAPHIC
+    };
+
+    /**
+     * Register this type with the TypeId system.
+     * \return the object TypeId
+     */
+    static TypeId GetTypeId();
+
+    GeocentricMobilityModel();
+    ~GeocentricMobilityModel() override = 0;
+
+    /// \brief Get the position by specifying the type of coordinates. Defaults to TOPOCENTRIC.
+    Vector GetPosition(PositionType type = PositionType::TOPOCENTRIC) const;
+
+    /// \brief Set the position by specifying the type of coordinates. Defaults to GEOGRAPHIC.
+    void SetPosition(Vector position, PositionType type = PositionType::GEOGRAPHIC);
+
+    /**
+     * \brief Computes elevation angle between a ground terminal and a HAPS/Satellite.
+     * After calculating the plane perpendicular to one cartesian position vector,
+     * the elevation angle is calculated using
+     * https://www.w3schools.blog/angle-between-a-line-and-a-plane. The altitude of the node passed
+     * as parameter needs to be higher.
+     * \param other pointer to the HAPS/Satellite mobility model
+     * \return the elevation angle in degrees
+     */
+    double GetElevationAngle(Ptr<const GeocentricMobilityModel> other);
+
+    /**
+     * \brief Get the reference point for coordinate translation
+     * \return Vector containing geographic reference point
+     */
+    Vector GetCoordinateTranslationReferencePoint() const;
+
+    /**
+     * \brief Set the reference point for coordinate translation
+     * \param refPoint vector containing the geographic reference point
+     */
+    void SetCoordinateTranslationReferencePoint(const Vector& refPoint);
+
+    /**
+     * \brief Get the Earth spheroid type used for this mobility model.
+     * \return Earth spheroid type
+     */
+    GeographicPositions::EarthSpheroidType GetEarthSpheroidType() const;
+
+  private:
+    /**
+     * \brief Get the TOPOCENTRIC coordinates. Override for ns-3 MobilityModel interface
+     * compatibility.
+     */
+    Vector DoGetPosition() const override;
+
+    /// \brief Get the position by specifying the type of coordinates.
+    virtual Vector DoGetPosition(PositionType type) const = 0;
+
+    /**
+     * \brief Set the GEOGRAPHIC coordinates. Override for ns-3 MobilityModel interface
+     * compatibility.
+     */
+    void DoSetPosition(const Vector& position) override;
+
+    /// \brief Set the position by specifying the type of coordinates.
+    virtual void DoSetPosition(Vector position, PositionType type) = 0;
+
+    /**
+     * \brief Get the distance between two nodes.
+     * \param other the mobility model for which the distance from will be calculated
+     * \return the distance in meters
+     */
+    virtual double DoGetDistanceFrom(Ptr<const GeocentricMobilityModel> other) const;
+
+    /**
+     * \brief Computes elevation angle between a ground terminal and a HAPS/Satellite.
+     * After calculating the plane perpendicular to one cartesian position vector,
+     * the elevation angle is calculated using
+     * https://www.w3schools.blog/angle-between-a-line-and-a-plane. The altitude of the node passed
+     * as parameter needs to be higher. \param other pointer to the HAPS/Satellite mobility model
+     * \return the elevation angle in degrees
+     */
+    virtual double DoGetElevationAngle(Ptr<const GeocentricMobilityModel> other);
+    /**
+     * \brief Set the reference point for coordinate translation
+     * \param refPoint vector containing the geographic reference point
+     */
+    virtual void DoSetCoordinateTranslationReferencePoint(const Vector& refPoint);
+    /**
+     * \brief Get the reference point for coordinate translation
+     * \return Vector containing geographic reference point
+     */
+    virtual Vector DoGetCoordinateTranslationReferencePoint() const;
+
+    GeographicPositions::EarthSpheroidType m_earthSpheroidType; //!< Spheroid model to use for Earth
+    Vector3D m_geographicReferencePoint; //!< Reference point for coordinate translation
+};
+
+} // namespace ns3
+
+#endif /* GEOCENTRIC_MOBILITY_MODEL_H */
diff --git a/src/propagation/model/channel-condition-model.cc b/src/propagation/model/channel-condition-model.cc
index 5fc088633..d5dcd20b7 100644
--- a/src/propagation/model/channel-condition-model.cc
+++ b/src/propagation/model/channel-condition-model.cc
@@ -18,9 +18,11 @@
 
 #include "channel-condition-model.h"
 
+#include "ns3/abort.h"
 #include "ns3/boolean.h"
 #include "ns3/double.h"
 #include "ns3/geocentric-constant-position-mobility-model.h"
+#include "ns3/geocentric-mobility-model.h"
 #include "ns3/log.h"
 #include "ns3/mobility-model.h"
 #include "ns3/node.h"
@@ -914,29 +916,22 @@ ThreeGppNTNDenseUrbanChannelConditionModel::ComputePlos(Ptr<const MobilityModel>
     Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
     Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
 
-    if (DynamicCast<GeocentricConstantPositionMobilityModel>(
-            ConstCast<MobilityModel>(a)) && // Transform to NS_ASSERT
-        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
-            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
-    {
-        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
-        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+    NS_ABORT_MSG_IF(!DynamicCast<GeocentricMobilityModel>(ConstCast<MobilityModel>(a)) ||
+                        !DynamicCast<GeocentricMobilityModel>(ConstCast<MobilityModel>(b)),
+                    "Mobility Models needs to be of type Geocentric for NTN scenarios");
+
+    auto aNTNMob = DynamicCast<GeocentricMobilityModel>(aMobNonConst);
+    auto bNTNMob = DynamicCast<GeocentricMobilityModel>(bMobNonConst);
 
-        if (aNTNMob->GetGeographicPosition().z <
-            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+    if (aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z <
+        bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC)
+            .z) // b is the HAPS/Satellite
         {
             elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
         }
         else // a is the HAPS/Satellite
         {
             elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
-        }
-    }
-    else
-    {
-        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
     }
 
     int elev_angle_quantized =
@@ -998,18 +993,16 @@ ThreeGppNTNUrbanChannelConditionModel::ComputePlos(Ptr<const MobilityModel> a,
     Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
     Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
 
-    if (DynamicCast<GeocentricConstantPositionMobilityModel>(
-            ConstCast<MobilityModel>(a)) && // Transform to NS_ASSERT
-        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
-            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
-    {
-        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
-        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+    NS_ABORT_MSG_IF(!DynamicCast<GeocentricMobilityModel>(ConstCast<MobilityModel>(a)) ||
+                        !DynamicCast<GeocentricMobilityModel>(ConstCast<MobilityModel>(b)),
+                    "Mobility Models needs to be of type Geocentric for NTN scenarios");
+
+    auto aNTNMob = DynamicCast<GeocentricMobilityModel>(aMobNonConst);
+    auto bNTNMob = DynamicCast<GeocentricMobilityModel>(bMobNonConst);
 
-        if (aNTNMob->GetGeographicPosition().z <
-            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+    if (aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z <
+        bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC)
+            .z) // b is the HAPS/Satellite
         {
             elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
         }
@@ -1017,11 +1010,6 @@ ThreeGppNTNUrbanChannelConditionModel::ComputePlos(Ptr<const MobilityModel> a,
         {
             elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
         }
-    }
-    else
-    {
-        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
-    }
 
     int elev_angle_quantized =
         (elev_angle < 10)
@@ -1082,29 +1070,22 @@ ThreeGppNTNSuburbanChannelConditionModel::ComputePlos(Ptr<const MobilityModel> a
     Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
     Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
 
-    if (DynamicCast<GeocentricConstantPositionMobilityModel>(
-            ConstCast<MobilityModel>(a)) && // Transform to NS_ASSERT
-        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
-            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
-    {
-        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
-        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+    NS_ABORT_MSG_IF(!DynamicCast<GeocentricMobilityModel>(ConstCast<MobilityModel>(a)) ||
+                        !DynamicCast<GeocentricMobilityModel>(ConstCast<MobilityModel>(b)),
+                    "Mobility Models needs to be of type Geocentric for NTN scenarios");
+
+    Ptr<GeocentricMobilityModel> aNTNMob = DynamicCast<GeocentricMobilityModel>(aMobNonConst);
+    Ptr<GeocentricMobilityModel> bNTNMob = DynamicCast<GeocentricMobilityModel>(bMobNonConst);
 
-        if (aNTNMob->GetGeographicPosition().z <
-            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+    if (aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z <
+        bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC)
+            .z) // b is the HAPS/Satellite
         {
             elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
         }
         else // a is the HAPS/Satellite
         {
             elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
-        }
-    }
-    else
-    {
-        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
     }
 
     int elev_angle_quantized =
@@ -1166,29 +1147,22 @@ ThreeGppNTNRuralChannelConditionModel::ComputePlos(Ptr<const MobilityModel> a,
     Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
     Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
 
-    if (DynamicCast<GeocentricConstantPositionMobilityModel>(
-            ConstCast<MobilityModel>(a)) && // Transform to NS_ASSERT
-        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
-            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
-    {
-        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
-        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+    NS_ABORT_MSG_IF(!DynamicCast<GeocentricMobilityModel>(ConstCast<MobilityModel>(a)) ||
+                        !DynamicCast<GeocentricMobilityModel>(ConstCast<MobilityModel>(b)),
+                    "Mobility Models needs to be of type Geocentric for NTN scenarios");
+
+    auto aNTNMob = DynamicCast<GeocentricMobilityModel>(aMobNonConst);
+    auto bNTNMob = DynamicCast<GeocentricMobilityModel>(bMobNonConst);
 
-        if (aNTNMob->GetGeographicPosition().z <
-            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+    if (aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z <
+        bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC)
+            .z) // b is the HAPS/Satellite
         {
             elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
         }
         else // a is the HAPS/Satellite
         {
             elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
-        }
-    }
-    else
-    {
-        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
     }
 
     int elev_angle_quantized =
diff --git a/src/propagation/model/three-gpp-propagation-loss-model.cc b/src/propagation/model/three-gpp-propagation-loss-model.cc
index 7e4ddd9c3..14ed3e074 100644
--- a/src/propagation/model/three-gpp-propagation-loss-model.cc
+++ b/src/propagation/model/three-gpp-propagation-loss-model.cc
@@ -18,10 +18,11 @@
 
 #include "three-gpp-propagation-loss-model.h"
 
+#include "ns3/abort.h"
 #include "ns3/boolean.h"
 #include "ns3/channel-condition-model.h"
 #include "ns3/double.h"
-#include "ns3/geocentric-constant-position-mobility-model.h"
+#include "ns3/geocentric-mobility-model.h"
 #include "ns3/log.h"
 #include "ns3/mobility-model.h"
 #include "ns3/node.h"
@@ -1602,17 +1603,16 @@ ThreeGppNTNDenseUrbanPropagationLossModel::GetLossLos(Ptr<MobilityModel> a,
     Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
     Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
 
-    if (DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(a)) &&
-        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
-            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
-    {
-        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
-        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+    NS_ABORT_MSG_IF(!DynamicCast<GeocentricMobilityModel>(ConstCast<MobilityModel>(a)) ||
+                        !DynamicCast<GeocentricMobilityModel>(ConstCast<MobilityModel>(b)),
+                    "Mobility Models needs to be of type Geocentric for NTN scenarios");
+
+    auto aNTNMob = DynamicCast<GeocentricMobilityModel>(aMobNonConst);
+    auto bNTNMob = DynamicCast<GeocentricMobilityModel>(bMobNonConst);
 
-        if (aNTNMob->GetGeographicPosition().z <
-            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+    if (aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z <
+        bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC)
+            .z) // b is the HAPS/Satellite
         {
             elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
         }
@@ -1620,11 +1620,6 @@ ThreeGppNTNDenseUrbanPropagationLossModel::GetLossLos(Ptr<MobilityModel> a,
         {
             elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
         }
-    }
-    else
-    {
-        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
-    }
 
     int elev_angle_quantized =
         (elev_angle < 10)
@@ -1678,17 +1673,16 @@ ThreeGppNTNDenseUrbanPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a,
     Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
     Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
 
-    if (DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(a)) &&
-        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
-            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
-    {
-        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
-        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+    NS_ABORT_MSG_IF(!DynamicCast<GeocentricMobilityModel>(ConstCast<MobilityModel>(a)) ||
+                        !DynamicCast<GeocentricMobilityModel>(ConstCast<MobilityModel>(b)),
+                    "Mobility Models needs to be of type Geocentric for NTN scenarios");
+
+    auto aNTNMob = DynamicCast<GeocentricMobilityModel>(aMobNonConst);
+    auto bNTNMob = DynamicCast<GeocentricMobilityModel>(bMobNonConst);
 
-        if (aNTNMob->GetGeographicPosition().z <
-            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+    if (aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z <
+        bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC)
+            .z) // b is the HAPS/Satellite
         {
             elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
         }
@@ -1696,11 +1690,6 @@ ThreeGppNTNDenseUrbanPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a,
         {
             elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
         }
-    }
-    else
-    {
-        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
-    }
 
     int elev_angle_quantized =
         (elev_angle < 10)
@@ -1766,17 +1755,16 @@ ThreeGppNTNDenseUrbanPropagationLossModel::GetShadowingStd(
     Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
     Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
 
-    if (DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(a)) &&
-        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
-            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
-    {
-        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
-        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+    NS_ABORT_MSG_IF(!DynamicCast<GeocentricMobilityModel>(ConstCast<MobilityModel>(a)) ||
+                        !DynamicCast<GeocentricMobilityModel>(ConstCast<MobilityModel>(b)),
+                    "Mobility Models needs to be of type Geocentric for NTN scenarios");
 
-        if (aNTNMob->GetGeographicPosition().z <
-            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+    auto aNTNMob = DynamicCast<GeocentricMobilityModel>(aMobNonConst);
+    auto bNTNMob = DynamicCast<GeocentricMobilityModel>(bMobNonConst);
+
+    if (aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z <
+        bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC)
+            .z) // b is the HAPS/Satellite
         {
             elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
         }
@@ -1784,11 +1772,6 @@ ThreeGppNTNDenseUrbanPropagationLossModel::GetShadowingStd(
         {
             elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
         }
-    }
-    else
-    {
-        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
-    }
 
     int elev_angle_quantized =
         (elev_angle < 10)
@@ -1897,17 +1880,16 @@ ThreeGppNTNUrbanPropagationLossModel::GetLossLos(Ptr<MobilityModel> a, Ptr<Mobil
     Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
     Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
 
-    if (DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(a)) &&
-        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
-            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
-    {
-        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
-        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+    NS_ABORT_MSG_IF(!DynamicCast<GeocentricMobilityModel>(ConstCast<MobilityModel>(a)) ||
+                        !DynamicCast<GeocentricMobilityModel>(ConstCast<MobilityModel>(b)),
+                    "Mobility Models needs to be of type Geocentric for NTN scenarios");
 
-        if (aNTNMob->GetGeographicPosition().z <
-            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+    auto aNTNMob = DynamicCast<GeocentricMobilityModel>(aMobNonConst);
+    auto bNTNMob = DynamicCast<GeocentricMobilityModel>(bMobNonConst);
+
+    if (aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z <
+        bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC)
+            .z) // b is the HAPS/Satellite
         {
             elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
         }
@@ -1915,11 +1897,6 @@ ThreeGppNTNUrbanPropagationLossModel::GetLossLos(Ptr<MobilityModel> a, Ptr<Mobil
         {
             elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
         }
-    }
-    else
-    {
-        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
-    }
 
     int elev_angle_quantized =
         (elev_angle < 10)
@@ -1971,17 +1948,16 @@ ThreeGppNTNUrbanPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a, Ptr<Mobi
     Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
     Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
 
-    if (DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(a)) &&
-        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
-            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
-    {
-        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
-        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+    NS_ABORT_MSG_IF(!DynamicCast<GeocentricMobilityModel>(ConstCast<MobilityModel>(a)) ||
+                        !DynamicCast<GeocentricMobilityModel>(ConstCast<MobilityModel>(b)),
+                    "Mobility Models needs to be of type Geocentric for NTN scenarios");
+
+    auto aNTNMob = DynamicCast<GeocentricMobilityModel>(aMobNonConst);
+    auto bNTNMob = DynamicCast<GeocentricMobilityModel>(bMobNonConst);
 
-        if (aNTNMob->GetGeographicPosition().z <
-            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+    if (aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z <
+        bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC)
+            .z) // b is the HAPS/Satellite
         {
             elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
         }
@@ -1989,11 +1965,6 @@ ThreeGppNTNUrbanPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a, Ptr<Mobi
         {
             elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
         }
-    }
-    else
-    {
-        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
-    }
 
     int elev_angle_quantized =
         (elev_angle < 10)
@@ -2063,17 +2034,16 @@ ThreeGppNTNUrbanPropagationLossModel::GetShadowingStd(
     Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
     Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
 
-    if (DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(a)) &&
-        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
-            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
-    {
-        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
-        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+    NS_ABORT_MSG_IF(!DynamicCast<GeocentricMobilityModel>(ConstCast<MobilityModel>(a)) ||
+                        !DynamicCast<GeocentricMobilityModel>(ConstCast<MobilityModel>(b)),
+                    "Mobility Models needs to be of type Geocentric for NTN scenarios");
 
-        if (aNTNMob->GetGeographicPosition().z <
-            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+    auto aNTNMob = DynamicCast<GeocentricMobilityModel>(aMobNonConst);
+    auto bNTNMob = DynamicCast<GeocentricMobilityModel>(bMobNonConst);
+
+    if (aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z <
+        bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC)
+            .z) // b is the HAPS/Satellite
         {
             elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
         }
@@ -2081,11 +2051,6 @@ ThreeGppNTNUrbanPropagationLossModel::GetShadowingStd(
         {
             elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
         }
-    }
-    else
-    {
-        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
-    }
 
     int elev_angle_quantized =
         (elev_angle < 10)
@@ -2195,29 +2160,24 @@ ThreeGppNTNSuburbanPropagationLossModel::GetLossLos(Ptr<MobilityModel> a,
     Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
     Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
 
-    if (DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(a)) &&
-        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
-            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
-    {
-        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
-        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+    NS_ABORT_MSG_IF(!DynamicCast<GeocentricMobilityModel>(ConstCast<MobilityModel>(a)) ||
+                        !DynamicCast<GeocentricMobilityModel>(ConstCast<MobilityModel>(b)),
+                    "Mobility Models needs to be of type Geocentric for NTN scenarios");
 
-        if (aNTNMob->GetGeographicPosition().z <
-            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+    auto aNTNMob = DynamicCast<GeocentricMobilityModel>(aMobNonConst);
+    auto bNTNMob = DynamicCast<GeocentricMobilityModel>(bMobNonConst);
+
+    if (aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z <
+        bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z)
         {
+        // b is the HAPS/Satellite
             elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
         }
-        else // a is the HAPS/Satellite
+    else
         {
+        // a is the HAPS/Satellite
             elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
         }
-    }
-    else
-    {
-        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
-    }
 
     int elev_angle_quantized =
         (elev_angle < 10)
@@ -2271,17 +2231,16 @@ ThreeGppNTNSuburbanPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a,
     Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
     Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
 
-    if (DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(a)) &&
-        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
-            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
-    {
-        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
-        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+    NS_ABORT_MSG_IF(!DynamicCast<GeocentricMobilityModel>(ConstCast<MobilityModel>(a)) ||
+                        !DynamicCast<GeocentricMobilityModel>(ConstCast<MobilityModel>(b)),
+                    "Mobility Models needs to be of type Geocentric for NTN scenarios");
 
-        if (aNTNMob->GetGeographicPosition().z <
-            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+    auto aNTNMob = DynamicCast<GeocentricMobilityModel>(aMobNonConst);
+    auto bNTNMob = DynamicCast<GeocentricMobilityModel>(bMobNonConst);
+
+    if (aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z <
+        bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC)
+            .z) // b is the HAPS/Satellite
         {
             elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
         }
@@ -2289,11 +2248,6 @@ ThreeGppNTNSuburbanPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a,
         {
             elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
         }
-    }
-    else
-    {
-        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
-    }
 
     int elev_angle_quantized =
         (elev_angle < 10)
@@ -2363,17 +2317,16 @@ ThreeGppNTNSuburbanPropagationLossModel::GetShadowingStd(
     Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
     Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
 
-    if (DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(a)) &&
-        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
-            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
-    {
-        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
-        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+    NS_ABORT_MSG_IF(!DynamicCast<GeocentricMobilityModel>(ConstCast<MobilityModel>(a)) ||
+                        !DynamicCast<GeocentricMobilityModel>(ConstCast<MobilityModel>(b)),
+                    "Mobility Models needs to be of type Geocentric for NTN scenarios");
+
+    auto aNTNMob = DynamicCast<GeocentricMobilityModel>(aMobNonConst);
+    auto bNTNMob = DynamicCast<GeocentricMobilityModel>(bMobNonConst);
 
-        if (aNTNMob->GetGeographicPosition().z <
-            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+    if (aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z <
+        bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC)
+            .z) // b is the HAPS/Satellite
         {
             elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
         }
@@ -2381,11 +2334,6 @@ ThreeGppNTNSuburbanPropagationLossModel::GetShadowingStd(
         {
             elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
         }
-    }
-    else
-    {
-        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
-    }
 
     int elev_angle_quantized =
         (elev_angle < 10)
@@ -2494,17 +2442,16 @@ ThreeGppNTNRuralPropagationLossModel::GetLossLos(Ptr<MobilityModel> a, Ptr<Mobil
     Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
     Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
 
-    if (DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(a)) &&
-        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
-            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
-    {
-        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
-        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+    NS_ABORT_MSG_IF(!DynamicCast<GeocentricMobilityModel>(ConstCast<MobilityModel>(a)) ||
+                        !DynamicCast<GeocentricMobilityModel>(ConstCast<MobilityModel>(b)),
+                    "Mobility Models needs to be of type Geocentric for NTN scenarios");
+
+    auto aNTNMob = DynamicCast<GeocentricMobilityModel>(aMobNonConst);
+    auto bNTNMob = DynamicCast<GeocentricMobilityModel>(bMobNonConst);
 
-        if (aNTNMob->GetGeographicPosition().z <
-            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+    if (aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z <
+        bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC)
+            .z) // b is the HAPS/Satellite
         {
             elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
         }
@@ -2512,11 +2459,6 @@ ThreeGppNTNRuralPropagationLossModel::GetLossLos(Ptr<MobilityModel> a, Ptr<Mobil
         {
             elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
         }
-    }
-    else
-    {
-        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
-    }
 
     NS_LOG_UNCOND("Elevation Angle: " << elev_angle);
 
@@ -2570,28 +2512,22 @@ ThreeGppNTNRuralPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a, Ptr<Mobi
     Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
     Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
 
-    if (DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(a)) &&
-        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
-            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
-    {
-        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
-        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+    NS_ABORT_MSG_IF(!DynamicCast<GeocentricMobilityModel>(ConstCast<MobilityModel>(a)) ||
+                        !DynamicCast<GeocentricMobilityModel>(ConstCast<MobilityModel>(b)),
+                    "Mobility Models needs to be of type Geocentric for NTN scenarios");
 
-        if (aNTNMob->GetGeographicPosition().z <
-            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+    auto aNTNMob = DynamicCast<GeocentricMobilityModel>(aMobNonConst);
+    auto bNTNMob = DynamicCast<GeocentricMobilityModel>(bMobNonConst);
+
+    if (aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z <
+        bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC)
+            .z) // b is the HAPS/Satellite
         {
             elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
         }
         else // a is the HAPS/Satellite
         {
             elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
-        }
-    }
-    else
-    {
-        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
     }
 
     int elev_angle_quantized =
@@ -2662,28 +2598,22 @@ ThreeGppNTNRuralPropagationLossModel::GetShadowingStd(
     Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
     Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
 
-    if (DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(a)) &&
-        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
-            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
-    {
-        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
-        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+    NS_ABORT_MSG_IF(!DynamicCast<GeocentricMobilityModel>(ConstCast<MobilityModel>(a)) ||
+                        !DynamicCast<GeocentricMobilityModel>(ConstCast<MobilityModel>(b)),
+                    "Mobility Models needs to be of type Geocentric for NTN scenarios");
+
+    auto aNTNMob = DynamicCast<GeocentricMobilityModel>(aMobNonConst);
+    auto bNTNMob = DynamicCast<GeocentricMobilityModel>(bMobNonConst);
 
-        if (aNTNMob->GetGeographicPosition().z <
-            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+    if (aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z <
+        bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC)
+            .z) // b is the HAPS/Satellite
         {
             elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
         }
         else // a is the HAPS/Satellite
         {
             elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
-        }
-    }
-    else
-    {
-        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
     }
 
     int elev_angle_quantized =
diff --git a/src/spectrum/examples/three-gpp-ntn-channel-example.cc b/src/spectrum/examples/three-gpp-ntn-channel-example.cc
index 8ee604bfb..97a260bc1 100644
--- a/src/spectrum/examples/three-gpp-ntn-channel-example.cc
+++ b/src/spectrum/examples/three-gpp-ntn-channel-example.cc
@@ -398,8 +398,10 @@ main(int argc, char* argv[])
     Ptr<GeocentricConstantPositionMobilityModel> rxMob =
         CreateObject<GeocentricConstantPositionMobilityModel>();
 
-    txMob->SetGeographicPosition(Vector(45.40869, 11.89448, 35786000)); // GEO over Padova
-    rxMob->SetGeographicPosition(Vector(45.40869, 11.89448, 14.0));     // Padova Coordinates
+    txMob->SetPosition(Vector(45.40869, 11.89448, 35786000),
+                       GeocentricMobilityModel::PositionType::GEOGRAPHIC); // GEO over Padova
+    rxMob->SetPosition(Vector(45.40869, 11.89448, 14.0),
+                       GeocentricMobilityModel::PositionType::GEOGRAPHIC); // Padova Coordinates
 
     // This is not strictly necessary, but is useful to have "sensible" values when using
     // GetPosition()
diff --git a/src/spectrum/model/three-gpp-channel-model.cc b/src/spectrum/model/three-gpp-channel-model.cc
index 1c6572c5f..1dbeb504a 100644
--- a/src/spectrum/model/three-gpp-channel-model.cc
+++ b/src/spectrum/model/three-gpp-channel-model.cc
@@ -22,7 +22,7 @@
 #include "three-gpp-channel-model.h"
 
 #include "ns3/double.h"
-#include "ns3/geocentric-constant-position-mobility-model.h"
+#include "ns3/geocentric-mobility-model.h"
 #include "ns3/integer.h"
 #include "ns3/log.h"
 #include "ns3/mobility-model.h"
@@ -2311,38 +2311,29 @@ ThreeGppChannelModel::GetThreeGppTable(const Ptr<const MobilityModel> aMob,
         Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(aMob);
         Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(bMob);
 
-        if (DynamicCast<GeocentricConstantPositionMobilityModel>(
-                ConstCast<MobilityModel>(aMob)) && // Transform to NS_ASSERT
-            DynamicCast<GeocentricConstantPositionMobilityModel>(
-                ConstCast<MobilityModel>(bMob))) // check if aMob and bMob are of type
-                                                 // GeocentricConstantPositionMobilityModel
-        {
-            Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
-                DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
-            Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
-                DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+        NS_ABORT_MSG_IF(!DynamicCast<GeocentricMobilityModel>(ConstCast<MobilityModel>(aMob)) ||
+                            !DynamicCast<GeocentricMobilityModel>(ConstCast<MobilityModel>(bMob)),
+                        "Mobility Models need to be of type Geocentric for NTN scenarios");
+
+        auto aNTNMob = DynamicCast<GeocentricMobilityModel>(aMobNonConst);
+        auto bNTNMob = DynamicCast<GeocentricMobilityModel>(bMobNonConst);
 
-            if (aNTNMob->GetGeographicPosition().z <
-                bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+        if (aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z <
+            bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z)
             {
                 elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
-                if (bNTNMob->GetGeographicPosition().z > 50000)
+            if (bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z > 50000)
                 {
                     satellite = true;
                 }
             }
-            else // a is the HAPS/Satellite
+        else
             {
                 elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
-                if (aNTNMob->GetGeographicPosition().z > 50000)
+            if (aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z > 50000)
                 {
                     satellite = true;
                 }
-            }
-        }
-        else
-        {
-            NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
         }
 
         int elev_angle_quantized =
-- 
2.40.1

